# -*- coding: utf-8 -*-
"""homeitb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/111NBMVJ9mtqmqCeDEU3EX5fKxEmdlK4j
"""

import statistics as st
import numpy as np
import pandas as pd
import scipy
from scipy.signal import butter, filtfilt, find_peaks, sosfiltfilt
import scipy.signal as signal
import pywt
import sys
import os
import matplotlib.pyplot as plt
from statsmodels.nonparametric.smoothers_lowess import lowess
from scipy.interpolate import interp1d

# Añadir modwtpy a path (si usas opción A)
sys.path.append(os.path.join(os.path.dirname(__file__), 'modwtpy'))
from modwt import modwt, modwtmra, imodwt

# Firebase
import firebase_admin
from firebase_admin import credentials, firestore
import threading

# Funciones de los filtros Highpass y Lowpass

#EL N aqui es importante, segun la señal se cambian valores
# Los valores del orden del filtro se han ido probando hasta dar valores correctos en comparación con lo que se realizó en Matlab
def highpass(x, Fc, Fs): # 'x' es la señal de entrada, 'Fc' la frecuencia de corte y 'Fs' la frecuencia de muestreo
    b, a = signal.butter(N=5, Wn=Fc, btype='highpass', fs=Fs) # N es el orden del filtro, Wn es la fercuencia de corte y Fs la frecuencia de muestreo
    return signal.filtfilt(b, a, x) # Se filtra la señal para eliminar el retraso de fase

def lowpass(x, Fc, Fs):# 'x' es la señal de entrada, 'Fc' la frecuencia de corte y 'Fs' la frecuencia de muestreo
    b, a = signal.butter(N=5, Wn=Fc, btype='low', fs=Fs)# N es el orden del filtro, Wn es la fercuencia de corte y Fs la frecuencia de muestreo
    return signal.filtfilt(b, a, x) # Se filtra la señal para eliminar el retraso de fase

# Funciones de suavizado lowess y movmean
def smooth_lowess(data, time, frac):# 'data' son los valores del eje Y, 'time' son los valores del eje X y 'frac' la cantidad de datos empleados al estimar cada valor Y
    smoothed = lowess(data, time, frac=frac, return_sorted=False) # No queremos ordenar los datos, se quedan como están
    return smoothed

def smooth_movmean(data):# Se hacfe una media movil de los datos de entrada. Estos datos se pasa a una Serie,empleando una ventaa de 3.
    return pd.Series(data).rolling(window=3, center=True, min_periods=1).mean().to_numpy() # Establece los datos como el centro
     #(si no daría NaN si no hubiera a la izquiera o derecha) y se hace la media de los datos

def valores_ITB(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie):

  # Filtrado de datos
  # Mano
  F = int(1/np.mean(np.diff(time_mano)))

  if F == 0:
        #print("Error: Frecuencia de muestreo igual a 0")
        return None, None, None, None
  LD = 5
  LI = 55

  time_mano = time_mano[int(F*LD)-1:int(F*LI)]
  filterECG_mano =  highpass(ECG_mano,0.55,F)
  filterECG_mano = filterECG_mano[int(F*LD)-1:int(F*LI)]

  filterPPG_mano = -(highpass(PPG_mano,0.45,F))
  filterPPG_mano = filterPPG_mano[int(F*LD)-1:int(F*LI)]

  # Pie
  Fpie = int(1/np.mean(np.diff(time_pie)))
  time_pie = time_pie[int(Fpie*LD)-1:int(Fpie*LI)]

  filterPPG_pie = (highpass(PPG_pie,0.45,Fpie)*(-1))

  filterPPG_pie = filterPPG_pie[int(Fpie*LD)-1:int(Fpie*LI)]

  time_pie_inicio = time_pie[0]
  time_pie = time_pie - time_pie_inicio

  time_mano_inicio = time_mano[0]
  time_mano = time_mano - time_mano_inicio

  # Variables
  w = smooth_movmean(filterECG_mano)
  x = smooth_movmean(filterECG_mano)
  y = smooth_lowess(filterPPG_mano,time_mano, int(0.25)* len(filterPPG_mano)) # Se hace *len debido a que es la cantidad de datos, entonces se hace el 0.25 * cantidad de datos de la señal
  z = smooth_lowess(filterPPG_pie,time_pie,int(0.35)* len(filterPPG_pie))# Se hace *len debido a que es la cantidad de datos, entonces se hace el 0.35 * cantidad de datos de la señal

  der = np.diff(x)

  # ECG
  # Normaliza el valor de la amplitud en voltios (V)
  w = np.array(w) / 1000
  tm = time_mano[:-1] # Vector de tiempo
  wt = modwt(w, 'sym4',4) # 4-level undecimatd DWT utilizando sym4 (Descomposición de la señal en los 4 coeficientes)
  wtrec = np.zeros(wt.shape)
  wtrec[1:4,:] = wt[1:4,:] # Se obtiene el  de la descomposición correspondiente a los coeficientes d2 y d4
  v = imodwt(wtrec, 'sym4') # Se reconstruye la señal con lo correspondiente a los coeficientes d2 y d4
  v = np.abs(v)**2 # Cuadrado de la magnitud de la señal
  avg = np.mean(v); # La media del cuadrado de la magnitud se usa como límite para la identificación de los picos de la señal
  peaks,locs = find_peaks(v[:-1], height = 2*avg, distance=int(0.5*F))# Find_peaks de Scipy devuelve los indices de los picos (peaks), Los valores de altura y distancia se han ido variando
  peak = v[:-1][peaks] # Amplitud de los picos (eje Y)
  locs = tm[peaks] # Eje X de los picos

  # HR
  nohb = len(locs) # Número de pulso s
  if nohb == 0:
      # print("Error: Número de pulsos igual a 0")
      return None, None, None, None

  timelimit = len(der)/F
  HR = (nohb*60)/timelimit
  tss = HR/60
  tss = 1 / tss
  tss = tss - (tss*0.15)

  #   # Se grafica la deteccion de picos
  # plt.figure(figsize=(15, 6))
  # plt.plot(tm, v[:-1], label='Señal filtrada') # Se plotea los datos der amplitud (menos el ultimo valor) respecto al tiempo
  # plt.plot(locs, v[peaks], 'rx', label='Picos')# Se plotea los datos de los picos del Eje X y Eje Y
  # plt.xlabel('Tiempo')
  # plt.ylabel('Amplitud')
  # plt.legend()

  # PPG mano
  # filterPPG_mano = filterPPG_mano/1000;
  y = y/1000;
  # wname = 'sym4';
  # level = 5;
  # sorh = 'soft';
  # thr = 4.5;
  # coeffs = pywt.wavedec(filterPPG_mano, wname, mode='symmetric', level=level, axis=-1)
  # coeffs_thresh = [coeffs[0]] + [pywt.threshold(c, thr, mode=sorh) for c in coeffs[1:]]
  # sigden_mano = pywt.waverec(coeffs_thresh, wname)


  # PPG pie
  # filterPPG_pie = filterPPG_pie/100
  z = z/100
  # wname2 = 'sym4'
  # level2 = 5
  # sorh2 = 'soft'
  # thr2 = 4.5
  # coeffs2 = pywt.wavedec(filterPPG_pie, wname2, mode='symmetric', level=level2, axis=-1)
  # coeffs_thresh2 = [coeffs2[0]] + [pywt.threshold(x, thr2, mode=sorh2) for x in coeffs2[1:]]
  # sigden_pie = pywt.waverec(coeffs_thresh2, wname2)

  # Picos mano
  d = int((tss-0.2) * F)# En Python distance es número de muestras, no tiempo

  Mpeaks,  Mlocs = find_peaks(y,distance=d) # Se obtienen los indices de los picos y un diccionario con información,como altura de los peaks
  Mpks = y[Mpeaks]  # Amplitud de los picos (eje Y)
  Mlocs = time_mano[Mpeaks]# Eje X de los picos

  # Filtramos los picos para que den valores correctos
  dist_time = 0.9 #Tiempo máximo entre picos ECG y PPG
  # Listas filtradas
  locs_f1 = []
  peak_f1 = []
  Mlocs_f = []
  Mpks_f = []

  for i in range(len(locs)):
      for j in range(len(Mlocs)):
          d1 = Mlocs[j] - locs[i]
          if d1 > 0 and d1 < dist_time:
              locs_f1.append(locs[i])
              peak_f1.append(peak[i])
              Mlocs_f.append(Mlocs[j])
              Mpks_f.append(Mpks[j])
              break


  # Picos pie
  Ppeaks, Plocs=  find_peaks(z,distance=d)
  Ppks = z[Ppeaks] # Amplitud de los picos (eje Y)
  Plocs = time_pie[Ppeaks]# Eje X de los picos

  # Filtramos los picos para que den valores correctos
  dist_time2 = 1.3 #Tiempo máximo entre picos ECG y PPG
  # Listas filtradas
  locs_f = []
  peak_f = []
  Plocs_f = []
  Ppks_f = []

  for i in range(len(locs)):
      for j in range(len(Plocs)):
          d2 = Plocs[j] - locs[i]
          if d2 > 0 and d2 < dist_time2:
              # Solo se agrega si hay match
              locs_f.append(locs[i])
              peak_f.append(peak[i])
              Plocs_f.append(Plocs[j])
              Ppks_f.append(Ppks[j])
              break


  # plt.figure(figsize=(10, 6))
  # plt.plot(tm, v[:-1]/10, label='ECG')
  # plt.plot(locs_f1, np.array(peak_f1)/10, 'v', color='blue', label='R peaks')
  # plt.plot(time_mano, y/100, 'r', label='PPG')
  # plt.plot(Mlocs_f, np.array(Mpks_f)/100, 'v', color='red', label='S peaks filtrados')

  # plt.xlabel('Time (seconds)')
  # plt.ylabel('Amplitude')
  # plt.legend()
  # plt.show()

  # plt.figure(figsize=(10, 6))
  # plt.plot(tm, v[:-1]/10, label='ECG')
  # plt.plot(locs_f, np.array(peak_f)/10, 'v', color='blue', label='R peaks')
  # plt.plot(time_pie, z/10, 'r', label='PPG')
  # plt.plot(Plocs_f, np.array(Ppks_f)/10, 'v', color='red', label='S peaks filtrados')

  # plt.xlabel('Time (seconds)')
  # plt.ylabel('Amplitude')
  # plt.legend()

  return locs_f1, Mlocs_f, locs_f, Plocs_f

# Cálculo de PTTh y PTTTf en Mano y Pie

def medias(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie):
  # Se obtienen las coordenadas de los picos de mano y pie
  locs_f1, Mlocs_f, locs_f, Plocs_f = valores_ITB(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie)
  v1 = []
  v2 = []

  # Si el valor es None no se calcula el valor, se devuelve None
  if locs_f1 == None or locs_f == None:
    return None, None

  else:
    # Se obtiene la media de la diferencia de puntos (PTTh y PTTf)
    for i in range(len(locs_f1)):
      v1.append(Mlocs_f[i]-locs_f1[i])

    for y in range(len(locs_f)):
      v2.append(Plocs_f[y] - locs_f[y])

    return round(np.mean(v1),3), round(np.mean(v2),3)


# Cálculo RA, LA, AR, AL, PA

def distancias(H):
  RA = -0.5263*(H**2) + 2.201*H - 1.311
  LA = -0.5018*(H**2) + 2.083*H - 1.245
  AR = -0.3993*(H**2) + 1.967*H - 0.8949
  AL = -0.5543*(H**2) + 2.488*H - 1.336
  PA = -0.2921*(H**2) + 1.055*H - 0.736

  ARf = AR + PA
  ALf = AL + PA

  return RA, LA, ARf, ALf


# Cálculo PWV y de ABI a partir de PWV

def PWV_ABI_D(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie,H):

  # Se calcula PTTh y PTTf para el lado derecho

  PTTrh, PTTrf = medias(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie)

  # Si los valores son None no se calcula el valor, se devuelve None
  if PTTrh == None or PTTrf == None:
    return None

  else:
  # Se calculan las distancias
    RA, LA, ARf, ALf = distancias(H)

    PWVrf = ARf / PTTrf
    PWVrh =  RA / PTTrh

    ABI_r = PWVrf / PWVrh

    return round(ABI_r,3)


def PWV_ABI_I(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie,H):

  # Se calcula PTTh y PTTf para el lado izquierdo

  PTTlh, PTTlf =  medias(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie)

  # Si los valores son None no se calcula el valor, se devuelve None
  if PTTlh == None or PTTlf == None:
    return None

  else:

    # Se calculan las distancias
    RA, LA, ARf, ALf = distancias(H)

    PWVlf = ALf / PTTlf
    PWVlh  = LA / PTTlh

    ABI_l = PWVlf / PWVlh

    return round(ABI_l,3)

# Inicializar Firebase
cred = credentials.Certificate("/etc/secrets/clave.json") # Credenciales de la Firestorer Database
if not firebase_admin._apps: # Si aún no se ha inicializado la App, se inicializa
                app = firebase_admin.initialize_app(cred)
db = firestore.client() # Se crea el cliente

# Función Listener de cambio del ITB al crearse un documento
def cambio_ITB(snapshot, changes, read_time):

    id_pac=''
    for change in changes: # Recorremos los cambios
        if change.type.name == "ADDED": # Si el cambio es de tipo AÑADIR (se ha añadido un doc):

            # El documento que se ha creado
            documento = change.document
            # print(f"Nueva medida añadida: {documento.id}") # Se muestra el nombre (id) del documento creado
            # print(f"Paciente: {documento.reference.parent.parent.get().to_dict().get('Name')}") # Se muestra el nombre del paciente donde se ha creado el doc

            # Obtención del valor de la altura del paciente
            doc_paciente = documento.reference.parent.parent
            datos_paciente = doc_paciente.get().to_dict()
            H = datos_paciente.get('Height')/100 # Se pasa a metros

            # Se hace el cambio
            campos = documento.to_dict() # Se obtienen los datos del documento creado

            if 'Dpie' in campos or 'Dmano' in campos: # Si en el documento hay un campo llamado Dpie o Dmano
              # Se obtienen todos los datos del paciente para obtener el ITB
              ECG_mano = np.array(campos['Dmano']['DCzn'])
              PPG_mano =np.array(campos['Dmano']['DMno'])
              time_mano = np.array(campos['Dmano']['TsM'])/1000
              time_pie =np.array(campos['Dpie']['TsP'])/1000
              PPG_pie = np.array(campos['Dpie']['DPie'])

              # # Si no se especifica de que lado son las muestras, no se actualiza el ITB
              # if 'Lado' not in campos:
              #   # print('No se pudo actualizar el valor del ITB ya que no se especifica si la muestra es del lado Derecho o Izquierdo')
              #   # print('---------------------------')

              # else:
              for titulo, valor in campos.items(): # Se recorren los campos del diccionario del documento
                      if titulo == 'Lado' and campos[titulo] == 'Derecho': # Si el campo es 'Lado'y es de tipo 'Derecho
                        if 'Dmano' in campos and 'DMno' in campos['Dmano']: # Solo si existen los dos campos de datos en Firebase
                          itb = PWV_ABI_D(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie,H) # Se obtiene el ITB con los datos del paciente
                          actualizar = {"Itb": itb}
                          documento.reference.update(actualizar) # Se actualiza el ITB
                          # print(f"ITB actualizado a valor: {itb} en lado {campos[titulo]}")
                          # print('---------------------------')

                      elif titulo == 'Lado' and campos[titulo] == 'Izquierdo': # Si el campo es 'Lado'y es de tipo 'Izquierdo'
                        if 'Dpie' in campos and 'DPie' in campos['Dpie']:# Solo si existen los dos campos de datos en Firebase
                          itb1 = PWV_ABI_I(ECG_mano,PPG_mano,time_mano, time_pie, PPG_pie,H)# Se obtiene el ITB con los datos del paciente
                          actualizar = {"Itb": itb1}
                          documento.reference.update(actualizar)# Se actualiza el ITB
                          # print(f"ITB actualizado a valor: {itb1} en lado {campos[titulo]}")
                          # print('---------------------------')

            # else:
            #     print('No se pudo actualizar el valor del ITB por falta de datos')
            #     print('---------------------------')


# Se seleccionan las colecciones y documentos
doc_ref = db.collection_group("lecturas")

# Iniciar el listener
doc_watch = doc_ref.on_snapshot(cambio_ITB)

# Mantener el script "vivo"
import time

# print("OBSERVANDO NUEVAS MUESTRAS EN LA BASE DE DATOS")
# print('---------------------------')


while True:
    time.sleep(1)